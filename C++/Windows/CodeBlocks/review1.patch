Index: src_2406/logind/login.h
===================================================================
--- src_2406/logind/login.h	(revision 146567)
+++ src_2406/logind/login.h	(revision 146568)
@@ -6,6 +6,10 @@
 
 #define LOGIN_MAX_AUTH_FAIL_TRY_NUM 50
 #define LOGIN_MAX_AUTH_WAIT_SECONDS 600
+#define USER_LOCK_MAX_SIZE              1024    /* 最大存储失败数组节点 */
+#define USER_LOCK_FAILED_NUM            5       /* 最多登录错误次数 */
+#define USER_LOCK_MAX_TIMES             30     /* 最长锁定时间 */
+#define LOCK_USER_FILE_PATH "/var//tmp/userLockInfoNode"
 
 #define LOGIN_LOG(priority, fmt, args...)                                                                              \
     if (hd) {                                                                                                          \
@@ -112,6 +116,21 @@
 #endif
 } login_handler_t;
 
+//用户锁定节点信息
+struct userLockInfoNode
+{
+    char username[32];
+    time_t lock_time;//锁定时间
+    int  failed_cnt;//鉴权失败次数
+    int  remainLockTimes;//登录剩余次数
+    int remainLockSecond;//锁定剩余时间
+};
+typedef enum user_auth_type
+{
+	USER_AUTH_SUCCESS = 0,
+	USER_AUTH_FAILED,		
+} user_auth_type_e;
+
 extern int logind_errno;
 extern int login_signal;
 
Index: src_2406/logind/login_main.c
===================================================================
--- src_2406/logind/login_main.c	(revision 146567)
+++ src_2406/logind/login_main.c	(revision 146568)
@@ -18,7 +18,6 @@
 #include "login_util.h"
 #include "login_imi.h"
 #include "hostp/hostp.h"
-
 #ifdef HAVE_AAA
 #include "login_aaa.h"
 #endif
@@ -239,10 +238,303 @@
     }
     return PAL_FALSE;
 }
+	
+int read_user_lock_info(const char *username, struct userLockInfoNode *result)
+{
+    if (!username || !result) {
+        return 0;
+    }
 
+    FILE *fp = fopen(LOCK_USER_FILE_PATH, "rb");
+    if (!fp) {
+        return 0; // 文件不存在或无法打开
+    }
+
+    // 加锁读取
+    if (flock(fileno(fp), LOCK_SH) != 0) {
+        fclose(fp);
+        return 0;
+    }
+
+    struct userLockInfoNode node;
+    int found = 0;
+
+    while (fread(&node, sizeof(struct userLockInfoNode), 1, fp) == 1) {
+        if (strcmp(node.username, username) == 0) {
+            *result = node;
+            found = 1;
+            break;
+        }
+    }
+
+    flock(fileno(fp), LOCK_UN);
+    fclose(fp);
+
+    return found;
+}
+
+// 写入用户锁定信息（覆盖或添加）
+int write_user_lock_info(const struct userLockInfoNode *node)
+{
+    if (!node || strlen(node->username) == 0) {
+        return -1;
+    }
+
+    char tmp_path[256];
+    snprintf(tmp_path, sizeof(tmp_path), "%s.tmp", LOCK_USER_FILE_PATH);
+
+    FILE *fp = fopen(LOCK_USER_FILE_PATH, "rb");
+    FILE *tmp_fp = fopen(tmp_path, "wb");
+    if (!tmp_fp) {
+        if (fp) fclose(fp);
+        return -1;
+    }
+
+    struct userLockInfoNode existing_node;
+
+    // 如果原文件存在，读取所有非匹配用户
+    if (fp) {
+        if (flock(fileno(fp), LOCK_SH) != 0) {
+            fclose(fp);
+            fclose(tmp_fp);
+            remove(tmp_path);
+            return -1;
+        }
+
+        while (fread(&existing_node, sizeof(struct userLockInfoNode), 1, fp)) {
+            if (strcmp(existing_node.username, node->username) != 0) {
+                fwrite(&existing_node, sizeof(struct userLockInfoNode), 1, tmp_fp);
+            }
+            // 不再记录 user_exists
+        }
+
+        flock(fileno(fp), LOCK_UN);
+        fclose(fp);
+    }
+
+    // 写入新/更新节点
+    fwrite(node, sizeof(struct userLockInfoNode), 1, tmp_fp);
+    fclose(tmp_fp);
+
+    // 原子替换
+    if (rename(tmp_path, LOCK_USER_FILE_PATH) != 0) {
+        remove(tmp_path);
+        return -1;
+    }
+
+    return 0;
+}
+// 删除某个用户的记录
+int delete_user_lock_info(const char *username)
+{
+    if (!username || strlen(username) == 0) {
+        return -1;
+    }
+
+    FILE *fp = fopen(LOCK_USER_FILE_PATH, "rb");
+    if (!fp) {
+        return -1;
+    }
+
+    char tmp_path[256];
+    snprintf(tmp_path, sizeof(tmp_path), "%s.tmp", LOCK_USER_FILE_PATH);
+    FILE *tmp_fp = fopen(tmp_path, "wb");
+    if (!tmp_fp) {
+        fclose(fp);
+        return -1;
+    }
+
+    if (flock(fileno(fp), LOCK_EX) != 0) {
+        fclose(fp);
+        fclose(tmp_fp);
+        remove(tmp_path);
+        return -1;
+    }
+
+    struct userLockInfoNode node;
+    int found = 0;
+
+    while (fread(&node, sizeof(struct userLockInfoNode), 1, fp)) {
+        if (strcmp(node.username, username) != 0) {
+            fwrite(&node, sizeof(struct userLockInfoNode), 1, tmp_fp);
+        } else {
+            found = 1;
+        }
+    }
+
+    flock(fileno(fp), LOCK_UN);
+    fclose(fp);
+    fclose(tmp_fp);
+
+    if (!found) {
+        remove(tmp_path);
+        return -1;
+    }
+
+    // 原子替换
+    if (rename(tmp_path, LOCK_USER_FILE_PATH) != 0) {
+        remove(tmp_path);
+        return -1;
+    }
+
+    return 0;
+}
+
+int checkUserLock(const char *userName, struct userLockInfoNode *result)
+{
+	struct userLockInfoNode tmpInfo;
+	time_t uptime = 0;
+	time_t Second = 0;
+	int blocked = 0;
+	int found = 0;
+	// 读取
+    memset(&tmpInfo, 0, sizeof(tmpInfo)); 
+    found = read_user_lock_info(userName, &tmpInfo);
+	
+	uptime = time((time_t *)NULL);
+	if (found)
+	{
+		/*进行时间的更新*/
+		Second = uptime - tmpInfo.lock_time;
+		if(tmpInfo.failed_cnt >= USER_LOCK_FAILED_NUM && Second > USER_LOCK_MAX_TIMES)
+		{
+			tmpInfo.failed_cnt = 0;//已过超时，重新置零
+			tmpInfo.remainLockTimes = USER_LOCK_FAILED_NUM - tmpInfo.failed_cnt;
+			tmpInfo.remainLockSecond = USER_LOCK_MAX_TIMES - Second;
+		}
+
+		/*此UserName已经失败过5次了, 不让登录了*/
+		if (tmpInfo.failed_cnt >= USER_LOCK_FAILED_NUM)
+		{
+			blocked = 1;
+			tmpInfo.remainLockSecond = USER_LOCK_MAX_TIMES - Second;
+		}
+		else if (tmpInfo.failed_cnt < USER_LOCK_FAILED_NUM)
+		{
+			blocked = 0;
+		}
+	}
+	
+	result->remainLockTimes = tmpInfo.remainLockTimes;
+	result->remainLockSecond = tmpInfo.remainLockSecond;
+	result->failed_cnt = tmpInfo.failed_cnt;
+	result->lock_time = tmpInfo.lock_time;
+	
+	return blocked;
+}
+/***********************************************************************
+ * Function:	 updateLockInfo
+ * Description:  更新锁定信息
+ *			
+ * Param:  [in] const user_auth_type_e update_type	 类型（成功/失败）
+ * Param:  [in] const char *userName				 用户名
+ * 
+ *	Return: int32_t
+	  成功:0
+	  失败: 
+ ************************************************************************/
+
+int updateLockInfo(const user_auth_type_e update_type, const char *userName)
+{
+	struct userLockInfoNode tmpInfo;
+	time_t uptime = 0;
+	time_t Second = 0;
+	int found = 0;
+	memset(&tmpInfo, 0, sizeof(tmpInfo)); 
+	found = read_user_lock_info(userName, &tmpInfo);
+	/*操作成功了, 并且表项中存在，删除表项*/
+	if (USER_AUTH_SUCCESS == update_type)
+	{
+		if (found)
+		{
+			delete_user_lock_info(userName);
+		}
+	}
+	else if(USER_AUTH_FAILED == update_type)
+	{
+		uptime = time((time_t *)NULL);
+
+		/*表项里存在此userName,更新时间和计数*/
+		if (found)
+		{
+			Second = uptime - tmpInfo.lock_time;
+			
+			/*判断时间是否超过最大时间限制*/
+			if (Second >= USER_LOCK_MAX_TIMES)
+			{
+				memset(&tmpInfo, 0, sizeof(struct userLockInfoNode));
+				tmpInfo.failed_cnt++;
+				tmpInfo.remainLockTimes = USER_LOCK_FAILED_NUM - tmpInfo.failed_cnt;
+				tmpInfo.remainLockSecond = USER_LOCK_MAX_TIMES - USER_LOCK_MAX_TIMES;
+				tmpInfo.lock_time = uptime;
+				strncpy(tmpInfo.username, userName, sizeof(tmpInfo.username) - 1);
+    			tmpInfo.username[sizeof(tmpInfo.username) - 1] = '\0';
+			}
+			else if (Second < USER_LOCK_MAX_TIMES)
+			{
+				//判断是否达到最大错误次数
+				if (tmpInfo.failed_cnt < USER_LOCK_FAILED_NUM)
+				{
+					//时间更新
+					tmpInfo.lock_time = uptime;
+					//锁定次数加1
+					tmpInfo.failed_cnt += 1; 
+					//未达到最大错误次数，进行累加，时间不变
+					if(tmpInfo.failed_cnt != USER_LOCK_FAILED_NUM) 
+					{
+						tmpInfo.remainLockTimes = USER_LOCK_FAILED_NUM - tmpInfo.failed_cnt;
+						tmpInfo.remainLockSecond = USER_LOCK_MAX_TIMES - USER_LOCK_MAX_TIMES;
+					}
+					else //达到最大错误次数
+					{
+						tmpInfo.remainLockTimes = USER_LOCK_FAILED_NUM - tmpInfo.failed_cnt;
+						tmpInfo.remainLockSecond = USER_LOCK_MAX_TIMES - 0;
+					}
+					//printf("opeartion failed, failed_cnt: %u, time:%ld", tmpInfo.failed_cnt, tmpInfo.lock_time);
+				}
+				else if(tmpInfo.failed_cnt >= USER_LOCK_FAILED_NUM)
+				{
+					tmpInfo.remainLockTimes = USER_LOCK_FAILED_NUM - USER_LOCK_FAILED_NUM;
+					tmpInfo.remainLockSecond = USER_LOCK_MAX_TIMES - Second;
+				}
+				
+			}
+		}
+		else//表项不存在记录则找个空位置创建记录
+		{
+			/* 如果表项里面不存在此用户记录，则创建记录 */
+			memset(&tmpInfo, 0, sizeof(struct userLockInfoNode));
+			strncpy(tmpInfo.username, userName, sizeof(tmpInfo.username) - 1);
+    		tmpInfo.username[sizeof(tmpInfo.username) - 1] = '\0';
+			tmpInfo.lock_time = uptime;
+			tmpInfo.failed_cnt += 1;
+			tmpInfo.remainLockTimes = USER_LOCK_FAILED_NUM - tmpInfo.failed_cnt;
+			tmpInfo.remainLockSecond = USER_LOCK_MAX_TIMES - USER_LOCK_MAX_TIMES;
+		}
+		printf("you have :%d times can try\n",tmpInfo.remainLockTimes);
+		write_user_lock_info(&tmpInfo);
+		
+	}
+	else
+	{
+		printf("update_type is Invalid arguments!");
+		return -1;
+	}
+	
+	return 0;
+}
+
 static int login_auth_local(login_handler_t* hd, bool_t* need_try)
 {
     hostp_auth_ret_t ret = 0;
+	struct userLockInfoNode lockInfo;
+	int lockFlag = 0;
+	char username[32] = {0};
+	
+	memset(&lockInfo, 0, sizeof(lockInfo));
+	/*用户线用户名规格31，防爆破功能只检测前31位，前31位相同视为同一用户*/
+	strncpy(username, hd->user.username, sizeof(username) - 1);
+	username[sizeof(username) - 1] = '\0';
 
     if (login_username_is_private(hd->user.username)) {
         hd->result.result = LINE_AUTH_FAILED;
@@ -249,7 +541,13 @@
         LOGIN_LOG(ZLOG_INFO, "deny private name '%s' to auth", hd->user.username);
         return 0;
     }
-
+	lockFlag = checkUserLock(username, &lockInfo);
+	if (1 == lockFlag) {
+		hd->result.result = LINE_AUTH_FAILED;
+		printf("User %s is Locked, please try after [%d] seconds\n", username, lockInfo.remainLockSecond);
+		return 0;
+	}
+	
     ret = hostp_local_user_auth(hd->user.username, hd->user.password);
     if (ret != HOSTP_AUTH_SUCCESS) {
         hd->result.result = LINE_AUTH_FAILED;
@@ -259,6 +557,15 @@
         hd->result.result = LINE_AUTH_SUCCESS;
         LOGIN_LOG(ZLOG_INFO, "user <%s> local auth success", hd->user.username);
     }
+	
+	updateLockInfo(ret == HOSTP_AUTH_SUCCESS?USER_AUTH_SUCCESS:USER_AUTH_FAILED, username);
+	memset(&lockInfo, 0, sizeof(lockInfo));
+	lockFlag = checkUserLock(username, &lockInfo);
+	if (1 == lockFlag) {
+		hd->result.result = LINE_AUTH_FAILED;
+		printf("User %s has failed 5 times, so forrbidden operation\n", hd->user.username);
+	}
+	
     return 0;
 }
 
